/************************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.8.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * Generated Date: 2/19/2020
 ***********************************************************************************************/

#include "azure_c_shared_utility/xlogging.h"
#include "azure_c_shared_utility/crt_abstractions.h"
#include "parson.h"
#include "sample_device_impl.h"
#include "pnp_schema_serializer.h"

//
// Serialize telemetry data
//

bool Sensor_SerializeTempTelemetry(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    double temp = Sensor_Telemetry_ReadTemp();

    int neededSize = snprintf(NULL, 0, "%f", temp);

    if (neededSize > size - 1)
    {
        LogError("Failed to build temp payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "%f", temp);
    }

    return true;
}

bool Sensor_SerializeHumidTelemetry(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    double humid = Sensor_Telemetry_ReadHumid();

    int neededSize = snprintf(NULL, 0, "%f", humid);

    if (neededSize > size - 1)
    {
        LogError("Failed to build humid payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "%f", humid);
    }

    return true;
}

bool Sensor_SerializeLocationTelemetry(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    SENSOR_LOCATION location;
    Sensor_Telemetry_ReadLocation(&location);

    JSON_Value *root_value = json_value_init_object();
    JSON_Object *root_object = json_value_get_object(root_value);

    json_object_set_number(root_object, "latitude", location.latitude);

    json_object_set_number(root_object, "longitude", location.longitude);

    char * serializedString = json_serialize_to_string(root_value);

    int neededSize = (int)strlen(serializedString);
    if (serializedString == NULL || neededSize > size - 1)
    {
        LogError("Failed to build location payload string");
        return false;
    }
    else
    {
        memcpy(payloadBuffer, serializedString, neededSize);
        free(serializedString);
    }

    json_value_free(root_value);

    return true;
}

//
// Serialize read-only property
//

bool Deviceinfo_SerializeManufacturerProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    char* manufacturer = Deviceinfo_Property_GetManufacturer();

    int neededSize = snprintf(NULL, 0, "\"%s\"", manufacturer);

    if (neededSize > size - 1)
    {
        LogError("Failed to build manufacturer payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "\"%s\"", manufacturer);
    }

    return true;
}

bool Deviceinfo_SerializeModelProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    char* model = Deviceinfo_Property_GetModel();

    int neededSize = snprintf(NULL, 0, "\"%s\"", model);

    if (neededSize > size - 1)
    {
        LogError("Failed to build model payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "\"%s\"", model);
    }

    return true;
}

bool Deviceinfo_SerializeSwVersionProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    char* swVersion = Deviceinfo_Property_GetSwVersion();

    int neededSize = snprintf(NULL, 0, "\"%s\"", swVersion);

    if (neededSize > size - 1)
    {
        LogError("Failed to build swVersion payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "\"%s\"", swVersion);
    }

    return true;
}

bool Deviceinfo_SerializeOsNameProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    char* osName = Deviceinfo_Property_GetOsName();

    int neededSize = snprintf(NULL, 0, "\"%s\"", osName);

    if (neededSize > size - 1)
    {
        LogError("Failed to build osName payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "\"%s\"", osName);
    }

    return true;
}

bool Deviceinfo_SerializeProcessorArchitectureProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    char* processorArchitecture = Deviceinfo_Property_GetProcessorArchitecture();

    int neededSize = snprintf(NULL, 0, "\"%s\"", processorArchitecture);

    if (neededSize > size - 1)
    {
        LogError("Failed to build processorArchitecture payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "\"%s\"", processorArchitecture);
    }

    return true;
}

bool Deviceinfo_SerializeProcessorManufacturerProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    char* processorManufacturer = Deviceinfo_Property_GetProcessorManufacturer();

    int neededSize = snprintf(NULL, 0, "\"%s\"", processorManufacturer);

    if (neededSize > size - 1)
    {
        LogError("Failed to build processorManufacturer payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "\"%s\"", processorManufacturer);
    }

    return true;
}

bool Deviceinfo_SerializeTotalStorageProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    long totalStorage = Deviceinfo_Property_GetTotalStorage();

    int neededSize = snprintf(NULL, 0, "%ld", totalStorage);

    if (neededSize > size - 1)
    {
        LogError("Failed to build totalStorage payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "%ld", totalStorage);
    }

    return true;
}

bool Deviceinfo_SerializeTotalMemoryProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    long totalMemory = Deviceinfo_Property_GetTotalMemory();

    int neededSize = snprintf(NULL, 0, "%ld", totalMemory);

    if (neededSize > size - 1)
    {
        LogError("Failed to build totalMemory payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "%ld", totalMemory);
    }

    return true;
}

bool Sensor_SerializeStateProperty(char * payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    bool state = Sensor_Property_GetState();

    int neededSize = snprintf(NULL, 0, "%s", state ? "true" : "false");

    if (neededSize > size - 1)
    {
        LogError("Failed to build state payload string");
        return false;
    }
    else
    {
        snprintf(payloadBuffer, size, "%s", state ? "true" : "false");
    }

    return true;
}

// Serialize command response.

bool Sensor_SerializeBlinkCommandResponse(SENSOR_BLINK_blinkResponse* response, char* payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    JSON_Value *root_value = json_value_init_object();
    JSON_Object *root_object = json_value_get_object(root_value);

    json_object_set_string(root_object, "description", response->description);

    char * serializedString = json_serialize_to_string(root_value);

    int neededSize = (int)strlen(serializedString);
    if (serializedString == NULL || neededSize > size - 1)
    {
        LogError("Failed to build blink payload string");
        return false;
    }
    else
    {
        memcpy(payloadBuffer, serializedString, neededSize);
        free(serializedString);
    }

    json_value_free(root_value);

    return true;
}

bool Sensor_SerializeUpdateFirmwareCommandResponse(SENSOR_UPDATEFIRMWARE_updateFirmwareResponse* response, char* payloadBuffer, int size)
{
    if (payloadBuffer == NULL)
    {
        return false;
    }

    memset(payloadBuffer, 0, size);

    JSON_Value *root_value = json_value_init_object();
    JSON_Object *root_object = json_value_get_object(root_value);

    json_object_set_string(root_object, "description", response->description);

    json_object_set_number(root_object, "statusCode", response->statusCode);

    char * serializedString = json_serialize_to_string(root_value);

    int neededSize = (int)strlen(serializedString);
    if (serializedString == NULL || neededSize > size - 1)
    {
        LogError("Failed to build updateFirmware payload string");
        return false;
    }
    else
    {
        memcpy(payloadBuffer, serializedString, neededSize);
        free(serializedString);
    }

    json_value_free(root_value);

    return true;
}

// Deserialize command request.
bool Sensor_DeserializeBlinkCommandRequest(long* interval, const unsigned char* pDataBuffer, int size)
{
    char* requestData = (char*)malloc(size + 1);
    if (requestData != NULL)
    {
        strncpy(requestData, (char*)pDataBuffer, size);
        requestData[size] = 0;
    }
    else
    {
        LogError("Failed to allocate memory for request payload");
        return false;
    }

    // Parse request parameters from request payload string
    JSON_Value *jsonValue = NULL;
    jsonValue = json_parse_string((const char*)requestData);

    *interval = (long)json_value_get_number(jsonValue);
    return true;
}

bool Sensor_DeserializeUpdateFirmwareCommandRequest(SENSOR_UPDATEFIRMWARE_firmwareRequest* request, const unsigned char* pDataBuffer, int size)
{
    // Get payload string
    char* requestData = (char*)malloc(size + 1);
    if (requestData != NULL)
    {
        strncpy(requestData, (char*)pDataBuffer, size);
        requestData[size] = 0;
    }
    else
    {
        LogError("Failed to allocate memory for request payload");
        return false;
    }

    // Parse request parameters from request payload string
    JSON_Value *jsonValue = NULL;
    jsonValue = json_parse_string((const char*)requestData);

    JSON_Object *jsonPayload = json_value_get_object(jsonValue);

    mallocAndStrcpy_s(&(request->firmwareUri), (char*)json_object_get_string(jsonPayload, "firmwareUri"));

    request->retry = json_object_get_boolean(jsonPayload, "retry");

    return true;
}
